# 限流

## 限流算法

1. 计数器算法 使用计数器实现限流算法，限流策略为在1秒内只允许有100个请求通过，一旦计数满了，拒绝所有的后续请求。假设0.1秒内就达到了100，那么剩下的0.9秒就无法提供服务了，这样在图形上就形成了一个突刺，这种现象称为“突刺现象”。

   > PS: 在自己的第三个项目中，Mobila App调用后端的API就是用了这种限流策略，1个用户1s内最多允许调用的10次，使用的是Google的Guava SDK。另外在自己写的秒杀项目中也是用了这种限流算法，具体实现是自定义了一个注解，使用次数的统计是在Redis中做的，将注解添加到需要限流的API接口上。

2. 漏桶算法 漏桶算法通过一个比较大的容器来接收请求，然后另一端匀速取出请求处理，处理速率是固定的，在一定程度上解决了突刺现象。当容器满了，就拒绝请求。设计是容器的容量尽可能承载1s内的请求，代码实现时可以使用队列来存放需要处理的请求。

   > PS：在自己的第四个项目中使用了这种类似的策略，不是来限制流量，而是服务端处理不过来，也是采用了漏桶的方式来先接收所有的请求，然后按频率依次处理，使用了LinkedBlockQueue来接收请求。当然也可以使用MQ来做。

3. 令牌桶算法 令牌桶算法在漏桶算法的基础上进行了改进，漏桶算法只能均匀地处理请求，令牌桶可以解决这个问题。令牌桶需要一个容器存储令牌，令牌以一定的速率往令牌桶中存放（避免了突刺现象），当桶中的令牌数量超过了桶的容量，则丢弃掉。当一个请求过来时，需要从令牌桶中获取令牌，获取令牌成功，则请求通过；如果令牌桶中的令牌消耗完毕了，则获取令牌失败，拒绝请求。 当网络设备衡量流量是否超过额定带宽时，需要查看令牌桶，而令牌桶中会放置一定数量的令牌，一个令牌允许接口发送或接收1bit数据（有时是1 Byte数据），当接口通过1bit数据后，同时也要从桶中移除一个令牌。当桶里没有令牌的时候，任何流量都被视为超过额定带宽,只有当桶中有令牌时，数据才可以通过接口。令牌桶中的令牌不仅仅可以被移除，同样也可以往里添加，所以为了保证接口随时有数据通过，就必须不停地往桶里加令牌，由此可见，往桶里加令牌的速度，就决定了数据通过接口的速度。因此，我们通过控制往令牌桶里加令牌的速度从而控制用户流量的带宽。而设置的这个用户传输数据的速率被称为承诺信息速率（CIR），通常以秒为单位。比如我们设置用户的带宽为1000bit每秒，只要保证每秒钟往桶里添加1000个令牌即可。

> Google开源的Guava项目中RateLimiter使用的就是令牌通算法

## 百问

> Nginx中如何限流 Nginx的限流主要是两种方式：限制访问频率和限制并发连接数。 1. 限制访问频率（正常流量） Nginx中我们使用 ngx\_http\_limit\_req\_module模块来限制请求的访问频率，基于漏桶算法原理实现。 2. 限制访问频率（突发流量） Nginx提供了 burst 参数来解决突发流量的问题，并结合 nodelay 参数一起使用。 burst=20 nodelay表示这20个请求立马处理，不能延迟，相当于特事特办。不过，即使这20个突发请求立马处理结束，后续来了请求也不会立马处理。burst=20 相当于缓存队列中占了20个坑，即使请求被处理了，这20个位置这只能按 100ms一个来释放。这就达到了速率稳定，但突然流量也能正常处理的效果。 3. 限制并发连接数 Nginx 的 ngx\_http\_limit\_conn\_module模块提供了对资源连接数进行限制的功能，使用 limit\_conn\_zone 和 limit\_conn 两个指令就可以了。
>
> * limit\_conn perip 20：对应的key是 $binary\_remote\_addr，表示限制单个IP同时最多能持有20个连接。
> * limit\_conn perserver 100：对应的key是 $server\_name，表示虚拟主机\(server\) 同时能处理并发连接的总数。注意，只有当 request header 被后端server处理后，这个连接才进行计数。
>
> Tomcat中如何限流 通过maxThreads来限制Tomcat Connector中允许开启的最大线程数，当达到这个值后，请求就会被阻塞
>
> SpringCloud Gateway中如何限流

